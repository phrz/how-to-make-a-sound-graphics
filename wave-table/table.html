<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three.js</title>
		<style>
			body{background:#000;margin:0;overflow:hidden}
			canvas{height:100%;margin:auto;display:block}
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="orbit.js"></script>

		<script type="x-shader/x-vertex" id="vertexShader">
			varying vec2 vUv;
			uniform float t;

			void main() {
				vUv = uv;
				vec3 newPosition = position;
				float xzDistanceFromOrigin = abs(position.x) + abs(position.z);
				newPosition.y += 3.0 * max(0.0, 0.7 - xzDistanceFromOrigin) 
					* (sin(10.0 * (newPosition.x + newPosition.z - t)) 
					+ cos(10.0 * (newPosition.x - newPosition.z - t)));

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>
		<script type="x-shader/x-vertex" id="fragmentShader">
			varying vec2 vUv;

			void main() {
				gl_FragColor = vec4(0.945, 0.922, 0.49, 1.);
			}
		</script>

		<script>
			const start = Date.now();

			const backgroundColor = 0x4048A1;
			const wireframeColor = 0xF1EB7D;
			const legHeight = 8;
			const tableX = 10;
			const tableZ = 15;
			const legSize = 1;
			const tableThickness = 0.7;

			const wireframe = true;
			const isometric = true;

			// SETUP

			var scene = new THREE.Scene();

			var nearClip = 0.1;
			var farClip = 1000;
			// var aspectRatio = window.innerWidth / window.innerHeight;
			var aspectRatio = 1;

			// FOV (degrees), aspect ratio, near clipping plane, far clipping plane
			if(!isometric) {
				const perspectiveFOV = 30;
				var camera = new THREE.PerspectiveCamera(
					perspectiveFOV, 
					aspectRatio,
					nearClip, 
					farClip
				);
				camera.position.set(30,30,30);
				var controls = new THREE.OrbitControls( camera );
				controls.update();
			} else {
				const distance = 10;
				var camera = new THREE.OrthographicCamera(
					-distance * aspectRatio, // left
					distance * aspectRatio,  // right
					distance,                // top
					-distance,               // bottom
					nearClip,
					farClip
				);
				const tilt = 500;

				// center point of the table
				const center = [(tableX)/2, 0, (tableZ)/2];
				camera.position.set(tilt+center[0],-1*(tilt+center[1]),tilt+center[2]);
			}

			camera.lookAt(0,0,0);

			var renderer = new THREE.WebGLRenderer();
			renderer.setClearColor( backgroundColor, 1 );
			// renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setSize(window.innerHeight, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			function shaderUpdateTimeUniform(shader) {
				// https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/
				shader.uniforms['t'].value = 0.0002 * (Date.now() - start);
				return shader;
			}

			function shaderMaterial() {
				let shader = new THREE.ShaderMaterial({
					uniforms: {
						t: {
							type: 'f', // float
							value: 0.0
						}
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				});
				if(wireframe) {
					shader.wireframe = true;
				}
				return shader;
			}

			function makeWireframeBox() {
				var geometry = new THREE.BoxGeometry(1, 1, 1);
				
				if(wireframe) {
					var material = new THREE.MeshBasicMaterial({ color: wireframeColor });
					material.wireframe = true;
				} else {
					var material = new THREE.MeshPhongMaterial({ color: wireframeColor });
				}

				var box = new THREE.Mesh(geometry, material);
				return box;
			}

			function makeTableTopShadedBox(shader) {
				var geometry = new THREE.BoxGeometry(1, 1, 1, 10, 1, 10);
				var box = new THREE.Mesh(geometry, shader);
				return box;
			}

			function makeTableLeg() {
				let tableLeg = makeWireframeBox();
				tableLeg.scale.set(legSize, legHeight, legSize);
				return tableLeg;
			}

			function makeTableTop(shader) {
				let tableTop = makeTableTopShadedBox(shader);
				tableTop.scale.set(tableX, tableThickness, tableZ);
				return tableTop;
			}

			let tableTopShader = shaderMaterial();
			function makeTable() {
				let table = new THREE.Object3D();

				// make four differently positioned legs
				let baseLeg = makeTableLeg();
				let tableLegs = [];
				for(let i = 0; i < 4; i++) {
					tableLegs.push(baseLeg.clone());
				}
				tableLegs[0].position.set(0, 0, 0);
				tableLegs[1].position.set(tableX - legSize, 0, 0);
				tableLegs[2].position.set(tableX - legSize, 0, tableZ - legSize);
				tableLegs[3].position.set(0, 0, tableZ - legSize);

				for(let tableLeg of tableLegs) {
					table.add(tableLeg);
				}

				let tableTop = makeTableTop(tableTopShader);
				tableTop.position.set(
					(tableX - legSize)/2,
					(legHeight + tableThickness)/2,
					(tableZ - legSize)/2
				);
				table.add(tableTop);

				// fix rotational origin
				table.position.set(
					(legSize - tableX) / 2, 
					0,
					(legSize - tableZ) /2
				);

				return table;
			}

			let table = makeTable();
			scene.add(table);

			// let ax = new THREE.AxesHelper(8);
			// scene.add(ax);

			// phong shader needs light
			if(!wireframe) {
				var pointLight = new THREE.PointLight( 0xffffff, 1, 100 );
				pointLight.position.set( 20, 20, 20 );
				scene.add( pointLight );
			}

			// RENDER LOOP
			function animate() {
				requestAnimationFrame(animate);

				tableTopShader = shaderUpdateTimeUniform(tableTopShader);
				// scene.rotation.y += 0.01;
				if(!isometric) {
					controls.update();
				}

				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>